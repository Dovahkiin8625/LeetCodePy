'''
羊、狼、农夫都在岸边，当羊的数量小于狼的数量时，狼会攻击羊，农夫则会损失羊。
农夫有一艘容量固定的船，能够承载固定数量的动物。
    要求求出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。只计算农夫去对岸的次数，回程时农夫不会运送羊和狼，
备注:农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊。农夫自身不占用船的容量。
输入描述
第一行输入为M，N，X，分别代表羊的数量，狼的数量，小船的容量输出描述
输出不损失羊情况下将全部羊和狼运到对岸需要的最小次数(若无法满足条件则输出0)

示例1:
输入:5 3 3
输出:3
说明:第一次运2只狼 第二次运3只羊 第三次运2只羊和1只狼
示例2:
输入:
5 4 1
输出:0
说明: 如果找不到不损失羊的运送方案，输出0
'''


import sys
m,n,x = (int(i) for i in input().strip().split())

# 狼小于船容量，一次将狼运送完
if n<x:
    print(1+(m//x if m%x==0 else m//x +1))
    sys.exit(0)
# 第一次运送狼，最大数量为x-1，所以狼数量n-(x-1)>=m时，无解
if n-m >= x-1:
    print(0)
    sys.exit(0)
# 其他情况，第一次运送x-1只狼， 第二次运送x只羊，
# 后续如果原岸羊的数量比狼多,或者狼羊能一次运送完,则送的羊数量比狼大一只，
# 如果运送过程中，发现原岸羊数量<=狼时（羊狼>0)，则下一次只能全运送狼
#   且满足条件: 运送的狼的数量 小于 对岸羊-狼的数量且小于船的容量(即运送船容量)
# 如果对岸羊-狼的数量小于1,则无解
t = 2
m = m-x
n = n-x+1
m2 = x
n2 = x-1

xm = x//2 if x%2==0 else x//2+1
xn = xm-1

while m>0:
    if (m-xm>n-xn) or (m==xm and n==xn):
        m -= xm
        n -= xn
        m2 += xm
        m2 += xn
        t += 1
    else:
        add_n = min(m2-n2,x)
        if add_n < 1:
            print(0)
            sys.exit(0)
        n -= add_n
        n2 += add_n
        t += 1
print(t)